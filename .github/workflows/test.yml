name: Sync rootfs
on:
#  schedule:
#    - cron:  '0 */4 * * *'

  workflow_dispatch:

jobs:

  Prepare:

    runs-on: ubuntu-20.04
    if: ${{ github.repository_owner == 'igorpecovnik' }}
    steps:

      - name: Cut the job into n chunks
        run: |

          mkdir -p temp
          rsync rsync://rsync.armbian.com/dl/_rootfs/ | awk '{ print $5}' | tail -n +3 > temp/rootfs.chunk
          split -d --number=l/10 --additional-suffix=.chunk --suffix-length=1 temp/rootfs.chunk temp/rootfs-

      - name: Cache Gradle packages
        uses: actions/cache@v2
        env:
          cache-name: cache-build
        with:
          path: temp
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ github.run_id }}

  Build: # short name because GH will expand with the matrix values
    needs: [ Prepare ]
    runs-on: ubuntu-20.04
    timeout-minutes: 480
    strategy:
      max-parallel: 5
      fail-fast: false # let other jobs try to complete if one fails
      matrix: 
        include: # build this way: cat userdata.csv | cut -d"/" -f1 | uniq | sed 's/.*/          - board: &/'
          - part: 0
          - part: 1
          - part: 2
          - part: 3
          - part: 4
          - part: 5
          - part: 6
          - part: 7
          - part: 8
          - part: 9

    steps:
      - name: Install depen
        run: sudo apt-get -y install parallel jq axel
      - name: Cache Gradle packages
        uses: actions/cache@v2
        env:
          cache-name: cache-build
        with:
          path: temp
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-${{ github.run_id }}

      - name: Download part
        run: |

          set +e
          CHUNK="${{ matrix.part }}"
          FILES=$(cat temp/rootfs-${CHUNK}.chunk)
          MIRRORS=$(curl -sq http://redirect.armbian.com/mirrors | jq -M -r | tr -d \" | grep http | grep -v github| tr -d , | tr -d " " | sort| uniq)
          for FILE in ${FILES[@]}
          do
            echo $FILE
            PARALLEL=$(
            for k in ${MIRRORS[@]}
            do
              echo "${k}_rootfs/${FILE}"
            done | parallel --halt now,fail=1 --jobs 32 wget -q --spider --timeout=5 --tries=2 --retry-connrefused {} 2>&1 >/dev/null)
            if [[ -n "${PARALLEL}" ]]; then
              REMOVE=$(echo $PARALLEL | egrep -o 'https?://[^ ]+/' | sed "s/_rootfs.*//" | sort | uniq)
              for l in ${REMOVE[@]}; do
                [[ "${DEBUG}" == yes ]] && echo "Removing mirror: $l"
                echo "Error,$l,$FILE" >> mirror.log
                MIRRORS=$(echo "${MIRRORS}" | sed "s|$l ||")
              done
              [[ $DEBUG == yes ]] && echo $PARALLEL | egrep -o 'https?://[^ ]+/' | sed 's/_rootfs.*//' | sort | uniq
            fi
          # download
          DOWNLOAD="axel -q -c -a "
          for m in ${MIRRORS[@]}; do
              DOWNLOAD=${DOWNLOAD}" ${m}_rootfs/${FILE}"
          done
          echo $DOWNLOAD
          echo "https://github.com/${{ github.repository }}/releases/download/_rootfs/}"
          if ! wget -q --spider --timeout=5 --tries=2 --retry-connrefused https://github.com/"${{ github.repository }}"/releases/download/_rootfs/${FILE}} ; then
              echo "Downloading ..."
              eval "${DOWNLOAD}"
              echo "UPLOAD=true" >> $GITHUB_ENV
          fi
          done
      - name: Upload artefacts
        if: ${{ env.UPLOAD == 'true' }}
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: *.tar*
          tag: "_rootfs"
          overwrite: true
          file_glob: true
          body: "This is Armbian file mirror at Github"
      - name: Upload logs
        uses: actions/upload-artifact@v2
        with:
          name: logs
          path: mirror.log

